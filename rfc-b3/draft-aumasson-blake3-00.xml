<?xml version="1.0" encoding="US-ASCII"?>
<!--
    Created: TBD

    Use "xml2rfc" to create nroff or txt output.
    I use 4-space tabs for clarity when organizing XML elements.
-->
<!DOCTYPE rfc>

<?rfc strict="yes" ?>
<?rfc toc="yes" ?>
<?rfc tocdepth="4" ?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="info" docName="draft-blake3-00" ipr="trust200902">
<front>
    <title>The BLAKE3 Cryptographic Hashing Primitive</title>

    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson" role="editor">
        <organization>Taurus SA</organization>
        <address>
            <postal>
                <street>Taurus SA</street>
                <street>Place Ruth Boesiger 6</street>
                <code>1201</code>
                <city>Geneva</city>
                <country>Switzerland</country>
            </postal>
            <email>jeanphilippe.aumasson@gmail.com</email>
            <uri>https://taurushq.com</uri>
        </address>
    </author>

    <author fullname="Samuel Neves"
            initials="S" surname="Neves">
        <organization></organization>
        <address>
            <postal>
                <street></street>
                <street></street>
                <region></region> <code></code>
                <country></country>
            </postal>
            <email></email>
            <uri></uri>
        </address>
    </author>

    <author fullname="Jack O'Connor"
            initials="J" surname="O'Connor">
        <organization>SpaceX</organization>
        <address>
            <postal>
                <street>356 167th Ave NE</street>
                <region>Bellevue</region> <code>WA 98008</code>
                <country>USA</country>
            </postal>
            <email>oconnor663@gmail.com</email>
            <uri>https://jacko.io</uri>
        </address>
    </author>

    <author fullname="Zooko Wilcox-O'Hearn"
            initials="Z" surname="Wilcox-O'Hearn">
        <organization></organization>
        <address>
            <postal>
                <street></street>
                <street></street>
                <region></region> <code></code>
                <country></country>
            </postal>
            <email></email>
            <uri></uri>
        </address>
    </author>

    <date month="March" year="2024" />

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>BLAKE3</keyword>
    <keyword>Cryptographic Hash</keyword>
    <keyword>Extendable-Output Function</keyword>
    <keyword>Key Derivation Function</keyword>
    <keyword>Pseudo-Random Function</keyword>
    <keyword>Message Authentication Code</keyword>

<abstract>
<t> This document specifies the cryptographic hashing primitive BLAKE3,
    a secure algorithm designed to be fast and highly parallelizable.
    Apart from the standard hashing functionality, BLAKE3 can serve to
    realize the following cryptographic functionalities:
    extendable-output function (XOF), key derivation function (KDF),
    pseudo-random function (PRF), and message authentication code (MAC).
    </t>
</abstract>
</front>

 <middle>

<section title="Introduction and Terminology">

<t> The <xref target="BLAKE3" /> cryptographic hash function was
    designed by Jack O'Connor, Jean-Philippe Aumasson, Samuel Neves, and
    Zooko Wilcox-O'Hearn.
    BLAKE3 is an evolution from its predecessors <xref target="BLAKE" /> and
    <xref target="BLAKE2" />. BLAKE2 is widely used in open-source
    software and in proprietary software. For example, the Linux kernel
    (from version 5.17) uses BLAKE2 in its cryptographic
    pseudorandom generator, and the WireGuard secure tunnel protocol
    uses BLAKE2 for hashing and keyed hashing. 
</t>

<t> 
    BLAKE3 was designed to be as secure as BLAKE2, yet considerably
    faster, thanks to 1) a compression function with a reduced number of
    rounds, and 2) a tree-based mode allowing implementations to
    leverage parallel processing. Specifically, BLAKE3 was designed to
    take advantage of multi-thread and multi-core processing, as well as
    of single-instruction multiple-data (SIMD) instructions of modern
    processor architectures. 
</t>    

<t>
    At the time of its publication, BLAKE3 was demonstrated to be
    approximately five times faster than BLAKE2 when hashing 16 kibibyte
    messages and using a single thread. When using multiple threads and
    hashing large messages, BLAKE3 can be more than twenty times faster
    than BLAKE2.
</t>


<t> 
    BLAKE3 was also designed to instantiate multiple cryptographic
    primitives, to offer a simpler and more efficient alternative to
    dedicated modes and algorithms. Said primitives include, aside from
    a basic hash function:

    <list style="hanging">
        <t hangText="Unkeyed hashing:"> ..
        </t>
        <t hangText="Keyed hashing:  "> ..
        </t>
        <t hangText="Key derivation: "> ..
        </t>
    </list>

TODO: Functionality: B3 modes, no need for other modes; cite HKDF,
HMAC 
</t>

<t>
    BLAKE3 can be a drop-in replacement for hash algorithms such as US
    Secure Hash Algorithms SHA, SHA-based .. TODO 
</t>

<t> TODO: Performance: superfast and parallel, any platform, multi-core
and SIMD
</t>

<t> TODO: Security: summary, bitlevel security
</t>

<t> BLAKE3 is believed to be highly secure and have good performance on
any platform, software or hardware.
</t>


<t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
    document are to be interpreted as described in <xref target="RFC2119" />.
    </t>
</section>

<!-- **************************************************   -->

<section title="Conventions and Constants" anchor="conventions">

<section title="Interfaces" anchor="interfaces">
<t> Describe the different modes/interfaces
    <list style="hanging">
        <t hangText="Unkeyed hashing:"> ..
        </t>
        <t hangText="Keyed hashing:  "> ..
        </t>
        <t hangText="Key derivation: "> ..
        </t>
    </list>
</t>
</section>



<section title="Arithmetic Notation">

<t> For real-valued x we define the following functions:
    <list style="hanging">
        <t hangText="   floor(x)">
            Floor, the largest integer less than or equal to x.</t>
        <t hangText="    ceil(x)">
            Ceiling, the smallest integer greater than or equal to x.</t>
        <t hangText="    frac(x)">
            Positive fractional part of x, frac(x) = x - floor(x).</t>
    </list></t>

<t> Operator notation in pseudocode:
    <list style="hanging">
        <t hangText="     2**n =">
            2 to the power "n". 2**0=1, 2**1=2, 2**2=4, 2**3=8, etc.</t>
        <t hangText="    a ^ b =">
            Bitwise exclusive-or operation between "a" and "b".</t>
        <t hangText="  a mod b =">
            Remainder "a" modulo "b", always in range [0, b-1].</t>
        <t hangText="   x >> n =">
            floor(x / 2**n). Logical shift "x" right by "n" bits.</t>
        <t hangText="   x &lt;&lt; n =">
            (x * 2**n) mod (2**w). Logical shift "x" left by "n".</t>
        <t hangText="  x >>> n ="> (x >> n) ^ (x &lt;&lt; (w - n)).
            Rotate "x" right by "n".</t>
    </list></t>
<figure><artwork><![CDATA[
]]></artwork></figure>
</section>


<section title="Little-Endian Convention">

    <t> BLAKE3 performs operations on 32-bit words, and on vectors of
    words.  Vector indexing is zero-based; the first element of an
    n-element vector "v" is v[0] and the last one is v[n - 1]. All
    elements is denoted by v[0..n-1].</t>

    <t>Byte (octet) streams are interpreted as words in little-endian
    order, with the least significant byte first.  Consider this
    sequence of eight hexadecimal bytes:</t>

<figure><artwork><![CDATA[
        x = 0x01 0x23 0x45 0x67 0x89 0xab 0xcd 0xef
]]></artwork></figure>

<t>When interpreted as a 32-bit word from the beginning memory
    address, x contains two 32-bit words x[0] and x[1], respectively
    equal to 0x67452301 and 0xefcdab89 in hexadecimal, or 1732584193 and
    4023233417 in decimal.</t>

</section>


<section title="Initial Value (IV)">


    <t> The initial value (IV) of BLAKE3 is the same as SHA-256 IV,
    namely the 8-word IV[0..7]: <xref target="RFC6234" />.</t> 

     <figure>
        <artwork type='text/ascii-art'>
          0x6a09e667
          0xbb67ae85
          0x3c6ef372
          0xa54ff53a
          0x510e527f
          0x9b05688c
          0x1f83d9ab
          0x5be0cd19
        </artwork>
      </figure>

      <t>This IV is set to the initial chaining value of BLAKE3 when no key is
      used. Otherwise the 256-bit key is set as the initial chaining
      value.</t>

      <t>This IV is also used as part of the compression function, where
      the first four words, IV[0..3] are copied into the 16-word local
      initial state, at positions v[8..11].</t>



</section>

<section title="Message Word Permutation" anchor="permutation">

    <t>
        BLAKE3 uses a permutation of the 16 indices (0 to 15). This permutation is defined as follows:

    </t>
    <texttable>
        <ttcol>0</ttcol>
        <ttcol>1</ttcol>
        <ttcol>2</ttcol>
        <ttcol>3</ttcol>
        <ttcol>4</ttcol>
        <ttcol>5</ttcol>
        <ttcol>6</ttcol>
        <ttcol>7</ttcol>
        <ttcol>8</ttcol>
        <ttcol>9</ttcol>
        <ttcol>10</ttcol>
        <ttcol>11</ttcol>
        <ttcol>12</ttcol>
        <ttcol>13</ttcol>
        <ttcol>14</ttcol>
        <ttcol>15</ttcol>
        <c>2</c>
        <c>6</c>
        <c>3</c>
        <c>10</c>
        <c>7</c>
        <c>0</c>
        <c>4</c>
        <c>13</c>
        <c>1</c>
        <c>11</c>
        <c>12</c>
        <c>5</c>
        <c>9</c>
        <c>14</c>
        <c>15</c>
        <c>8</c>
    </texttable>


</section>

<section title="Compression Function Flags" anchor="flags">

    <t>
        The compression function of BLAKE3 uses a set of flags to
        control various aspects of its operation. These flags are
        defined as follows: 
    </t>
    <t>
        <list style="symbols">
            <t>CHUNK_START (0x01): This flag is set for the first block
            of each chunk.</t>

            <t>CHUNK_END (0x02): This flag signals the end of the chunk.
            It is set for the compression function of the last block
            within a chunk. If a chunk contains only one block, that
            block sets both CHUNK_START and CHUNK_END.</t>

            <t>PARENT (0x04): In the binary tree structure, this flag is
            set on parent nodes (non-chunk nodes). It signals that
            the node combines the 32-byte outputs of nodes in the tree
            (chunks of parents). A parent node always processes exactly 64
            bytes, that is, the concatenation of two 32-byte output
            values from a child node.
            </t>

            <t>ROOT (0x08): This flag is assigned to the final node in
            the tree, representing the root. The root node may be a
            parent node, but may also be a chunk processing leaf (if
            there is a single chunk). In this latter case, only the last
            compression functoin sets the ROOT flag. In the case of a
            parent node, there is a single compression function, which
            sets the ROOT flag.
            </t>

            <t>KEYED_HASH (0x10): This flag is set to all compression
            functions when using BLAKE3 in the keyed_hash mode. In this
            mode, a 256-bit key is used as initial chaining value
            instead of IV.
            </t>
            <t>DERIVE_KEY_CONTEXT (0x20) and DERIVE_KEY_MATERIAL (0x40):
            These flags are used in BLAKE3's derive_key mode, where the
            context string is first hashed TODOOO</t>
        </list>
    </t>
    <texttable>
        <ttcol>Flag</ttcol>
        <ttcol>Description</ttcol>
        <c>---------------------------------------</c>
        <c>---------------------------------------</c>
        <c>0x01</c> <c>CHUNK_START</c>
        <c>0x02</c> <c>CHUNK_END</c>
        <c>0x04</c> <c>PARENT</c>
        <c>0x08</c> <c>ROOT</c>
        <c>0x10</c> <c>KEYED_HASH</c>
        <c>0x20</c> <c>DERIVE_KEY_CONTEXT</c>
        <c>0x40</c> <c>DERIVE_KEY_MATERIAL</c>
    </texttable>

</section>
</section>


<!-- **************************************************   -->

<section anchor="compression" title="Compression Function">

<t>BLAKE3 iterates the compression function when processing chunks</t>

<section title="Compression Function Input Values">

    <t> These variables are used in the algorithm description.
    <list style="hanging">
        <t hangText="    h[0..7]">
        The hash chaining value, 8 words of 32 bits.</t>
        <t hangText="   m[0..15]">
        The message block processed, 16 words of 32 bits.</t>
        <t hangText="    t[0..1]">
        A 64-bit counter whose lower-order 32-bit word is t[0] and
        higher-order 32-bit word is t[1].</t>
        <t hangText="        len">
        32-bit word encoding the number of application data bytes in
        the block, at least 1 and at most 64. That is, ad is equal to 64
        minus the number of padding bytes (which are set to zero).</t>
        <t hangText="       flag">
        32-bit word encoding the flags defined for a given compression
        function call, see <xref target="flags" />.</t>

    </list>
    </t>
<figure><artwork><![CDATA[
]]></artwork></figure>
</section>

<section title="Quarter-Round Function G">

<t> The G primitive function mixes two input words "x" and "y" into four
    words indexed by "a", "b", "c", and "d" in the working vector v[0..15].
    The full modified vector is returned. 
</t>

<figure><artwork><![CDATA[
    FUNCTION G( v[0..15], a, b, c, d, x, y )
    |
    |   v[a] := (v[a] + v[b] + x) mod 2**32
    |   v[d] := (v[d] ^ v[a]) >>> 16
    |   v[c] := (v[c] + v[d])     mod 2**32
    |   v[b] := (v[b] ^ v[c]) >>> 12
    |   v[a] := (v[a] + v[b] + y) mod 2**32
    |   v[d] := (v[d] ^ v[a]) >>> 8 
    |   v[c] := (v[c] + v[d])     mod 2**32
    |   v[b] := (v[b] ^ v[c]) >>> 7 
    |
    |   RETURN v[0..15]
    |
    END FUNCTION.
]]></artwork></figure>
</section>

<section title="Compression Function Processing">

    <t> BLAKE3's compression function returns a new 8-word state, given
    as input an 8-word state h, a 16-word message m, a 2-word counter t,
    and a word flag.</t>

    <t>BLAKE3's compression does 8 rounds, numbered 0 to 7. Each round
    includes 8 calls to the G functoin.</t>

    <t>TODO: adapt pseudocode, deal with permutation</t>

<figure><artwork><![CDATA[
    FUNCTION BLAKE3_F( h[0..7], m[0..15], t, len, flags )
    |
    |   // Initialize local 16-word vector v[0..15]
    |   v[0..7] := h[0..7]              // First half from state.
    |   v[8..11] := IV[0..7]            // Second half from IV.
    |
    |   v[12] := v[12] ^ (t mod 2**w)   // Low word of the offset.
    |   v[13] := v[13] ^ (t >> w)       // High word.
    |
        **TODO**
    |   IF f = TRUE THEN                // last block flag?
    |   |   v[14] := v[14] ^ 0xFF..FF   // Invert all bits.
    |   END IF.
    |
    |   // Cryptographic mixing
    |   FOR i = 0 TO 7 DO           // 8 rounds.
    |   |
    |   |   v := G( v, 0, 4,  8, 12, m[s[ 0]], m[s[ 1]] )
    |   |   v := G( v, 1, 5,  9, 13, m[s[ 2]], m[s[ 3]] )
    |   |   v := G( v, 2, 6, 10, 14, m[s[ 4]], m[s[ 5]] )
    |   |   v := G( v, 3, 7, 11, 15, m[s[ 6]], m[s[ 7]] )
    |   |
    |   |   v := G( v, 0, 5, 10, 15, m[s[ 8]], m[s[ 9]] )
    |   |   v := G( v, 1, 6, 11, 12, m[s[10]], m[s[11]] )
    |   |   v := G( v, 2, 7,  8, 13, m[s[12]], m[s[13]] )
    |   |   v := G( v, 3, 4,  9, 14, m[s[14]], m[s[15]] )
    |   |
    |   END FOR
    |
    |   FOR i = 0 TO 7 DO               // XOR the two halves.
    |   |   h[i] := h[i] ^ v[i] ^ v[i + 8]
    |   END FOR.
    |
    |   RETURN h[0..7]                  // New state.
    |
    END FUNCTION.
]]></artwork></figure>
</section>
</section>

<!-- **************************************************   -->

<section anchor="treemode" title="Tree Mode of Operation">

<t>Intro to tree processing; chunks as leaves; explain padding with zeros</t>

</section>

<section anchor="chunkspro" title="Chunk Processing">

    <t>
        BLAKE3's chunk processing divides the BLAKE3 input into
        1024-byte chunks, which will be leaves of a binary tree. The
        last chunk will be of less than 1024 bytes if the message byte
        length is not a multiple of 1024.
    </t>
    <t>
        Chunks are ivided into 64-byte blocks. The last block of
        the last chunk may be shorter, but not empty, unless the entire
        input is empty. If necessary, the last block is padded with
        zeros to be 64-byte.
    </t>
    <t> 
        Each chunk is processed by iterating the compression function
        (1024/64 = 16 times for a full 1024-byte chunk) to process
        64-byte blocks, each parsed as 16 32-bit little-endian words.
        The output of each compression function is h[0..7], the 8-word
        truncated output, which is the input of the next compression
        function (and the output of the chunk processing for the last
        compression function call).
    </t>
    <t>
        Compression function input arguments are set as follows: 
    <list style="hanging">
        <t hangText="    h[0..7]">
        For the first block of a chunk, this is set either to the key,
        or to the IV if no key is defined. For subsequent block, h is
        set to the output of the previous block's compression.</t>
        <t hangText="   m[0..15]">
        This is the block processed by the compression function.</t>
        <t hangText="    t[0..1]">
        The counter t for each block is the chunk index, that is, 0 for
        all blocks in the first chunk, 1 for all blocks in the second
        chunk, and so on.</t>
        <t hangText="        len">
        The block length is set to 64 for all blocks except the last
        block of a chunk, where it is the number of data bytes (thus
        excluding padding zeros.)</t>
        <t hangText="       flag">
        The first block of each chunk sets the CHUNK_START flag (cf.
        Table 3), and the last block of each chunk sets the CHUNK_END
        flag. If a chunk contains only one block, that block sets both
        CHUNK_START and CHUNK_END. If a chunk is the root of its tree,
        the last block of that chunk also sets the ROOT flag. Multiple
        flags may thus be set.</t>
    </list>
    </t>
    <t>
        Can have multiple flags.
        The flags used in chunk processing are as follows:
        <list style="symbols">
            <t>CHUNK_START (0x01): This flag is set for the first block
            of each chunk.</t>

            <t>CHUNK_END (0x02): This flag signals the end of the chunk.</t>

            <t>PARENT (0x04): In the binary tree structure, this flag is
            used on internal nodes (non-leaf nodes). It signals that
            the node is a result of combining two child chunks or nodes
            in the tree. A parent node always processes exactly 64
            bytes.
            </t>

            <t>ROOT (0x08): This flag is assigned to the final node in
            the tree, representing the root. The root node is a
            particular parent node.
            </t>

            <t>KEYED_HASH (0x10), DERIVE_KEY_CONTEXT (0x20), and
            DERIVE_KEY_MATERIAL (0x40): These flags are used in BLAKE3's keyed
            hashing and key derivation modes, not in the standard hash
            mode. They signal specific processing contexts as per the
            mode of operation.</t>
        </list>
    </t>
    <t>
        More than one flag may be set, for ex..
    </t>

</section>

<section anchor="treestruct" title="Binary Tree Processing">

    <t>
        BLAKE3 operates in a parallel tree mode using a binary tree
        structure. The input data is divided into fixed-size chunks of
        1024 bytes, and each chunk is processed independently. Chunks
        are then hashed into 256-bit (32-byte) nodes in the binary tree.
    </t>
    <t>
        The tree's leaves represent individual chunk hashes, and
        internal nodes are formed by hashing the concatenation of their
        children's hashes using the BLAKE3 compression function. Each
        node uses a unique flag to indicate its position (e.g., chunk
        start, chunk end, parent, and root).
    </t>
    <t>
        The root of this tree represents the final hash output. This
        approach leverages parallel processing capabilities, as each
        chunk can be processed independently and concurrently. The use
        of flags in the compression function ensures the proper
        structuring and differentiation of tree components, maintaining
        the security and integrity of the hash output.
    </t>
    <t>
        Describe flags, parent/root logic.
    </t>

</section>

</section>

<!-- **************************************************   -->

<section anchor="apps" title="Applications">

<t>List applications similarly to the specs</t>

</section>

<!-- **************************************************   -->

<section anchor="impl" title="Implementation Considerations">

<t>B3 impls MAY use.. parallel impl, SIMD usage, incremental hashing
</t>
</section>



<section anchor="Acknowledgements" title="Acknowledgements">

<t> 
    TODO
</t>

</section>

<section anchor="IANA" title="IANA Considerations">

<t> This memo includes no request to IANA.</t>

</section>

<section anchor="Security" title="Security Considerations">

<t> TODO: Security level summary. Not for password hashing.
    We refer the reader to <xref target="BLAKE3" /> and
    <xref target="BLAKE3" />
    for detailed cryptanalytic rationale behind its design.</t>

<t> TODO: Note on source code security (reference, no guarantees wrt
    side channels, software security, use at your own risk). </t>
</section>

</middle>
<back>

<references title="Informative References">

<reference anchor="BLAKE3" target="https://github.com/BLAKE3-team/BLAKE3">
    <front>
    <title>BLAKE3</title>
    <author fullname="Jack O'Connor"
            initials="J" surname="O'Connor" />
    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson"  />
    <author fullname="Samuel Neves"
            initials="S" surname="Neves" />
    <author fullname="Zooko Wilcox-O'Hearn"
            initials="Z" surname="Wilcox-O'Hearn" />
    <date month="January" year="2020" />
    </front>
</reference>

<reference anchor="BLAKE2" target="https://www.blake2.net/">
    <front>
    <title>BLAKE2: simpler, smaller, fast as MD5</title>
    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson"  />
    <author fullname="Samuel Neves"
            initials="S" surname="Neves" />
    <author fullname="Zooko Wilcox-O'Hearn"
            initials="Z" surname="Wilcox-O'Hearn" />
    <author fullname="Christian Winnerlein"
            initials="C" surname="Winnerlein" />
    <date month="January" year="2013" />
    </front>
</reference>

<reference anchor="BLAKE" target="https://aumasson.jp/blake/">
    <front>
    <title>The Hash Function BLAKE</title>
    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson" />
    <author fullname="Willi Meier"
            initials="W" surname="Meier" />
    <author fullname="Raphael C.-W. Phan"
            initials="R C-W" surname="Phan" />
    <author fullname="Luca Henzen"
            initials="L" surname="Henzen" />
    <date month="October" year="2008" />
    </front>
</reference>

<reference anchor="RFC7693">
    <front>
    <title> The BLAKE2 Cryptographic Hash and Message Authentication
    Code (MAC)</title>
    <author fullname="Markku-Juhani O. Saarinen" initials="M-J" surname="Saarinen" />
    <author fullname="Jean-Philippe Aumasson" initials="J-P"
    surname="Aumasson" />
    <date month="November" year="2015" />
    </front>
    <seriesInfo name="RFC" value="7693" />
</reference>

<reference anchor="RFC2119">
    <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="Scott Bradner" initials="S" surname="Bradner" />
    <date month="March" year="1997" />
    </front>
    <seriesInfo name="RFC" value="2119" />
    <seriesInfo name="BCP" value="14" />
</reference>

<reference anchor="RFC6151">
    <front>
    <title> Updated Security Considerations for the MD5 Message-Digest
            and the HMAC-MD5 Algorithms</title>
    <author fullname="Sean Turner" initials="S" surname="Turner" />
    <author fullname="Lily Chen" initials="L" surname="Chen" />
    <date month="March" year="2011" />
    </front>
    <seriesInfo name="RFC" value="6151" />
</reference>

<reference anchor="RFC6234">
    <front>
    <title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
    <author fullname="Donald Eastlake" initials="D" surname="Eastlake" />
    <author fullname="Tony Hansen" initials="T" surname="Hansen" />
    <date month="May" year="2011" />
    </front>
    <seriesInfo name="RFC" value="6234" />
</reference>

<reference anchor="FIPS140-2IG">
    <front>
    <title> Implementation Guidance for FIPS PUB 140-2 and the
            Cryptographic Module Validation Program</title>
    <author fullname="NIST" initials="US" surname="NIST" />
    <date month="January" year="2015" />
    </front>
</reference>
</references>

<section title="BLAKE3 Implementations" anchor="b3src">
<t>Cite Rust and C ref code, explain why not copied in the RFC, give git
references
</t>
</section>

<section title="Example of BLAKE3 Computation" anchor="b3test">

<t> 
    Give examples of intermediate/final values for 1) the compression function,
    and 2) for each of the modes
</t>

<figure><artwork><![CDATA[
       m[16] = 00636261 00000000 00000000 00000000 00000000 00000000
               00000000 00000000 00000000 00000000 00000000 00000000
               00000000 00000000 00000000 00000000

(i=0)  v[16] = 6B08E647 BB67AE85 3C6EF372 A54FF53A 510E527F 9B05688C
               1F83D9AB 5BE0CD19 6A09E667 BB67AE85 3C6EF372 A54FF53A
               510E527C 9B05688C E07C2654 5BE0CD19

(i=1)  v[16] = 16A3242E D7B5E238 CE8CE24B 927AEDE1 A7B430D9 93A4A14E
               A44E7C31 41D4759B 95BF33D3 9A99C181 608A3A6B B666383E
               7A8DD50F BE378ED7 353D1EE6 3BB44C6B

(i=2)  v[16] = 3AE30FE3 0982A96B E88185B4 3E339B16 F24338CD 0E66D326
               E005ED0C D591A277 180B1F3A FCF43914 30DB62D6 4847831C
               7F00C58E FB847886 C544E836 524AB0E2

(i=3)  v[16] = 7A3BE783 997546C1 D45246DF EDB5F821 7F98A742 10E864E2
               D4AB70D0 C63CB1AB 6038DA9E 414594B0 F2C218B5 8DA0DCB7
               D7CD7AF5 AB4909DF 85031A52 C4EDFC98

(i=4)  v[16] = 2A8B8CB7 1ACA82B2 14045D7F CC7258ED 383CF67C E090E7F9
               3025D276 57D04DE4 994BACF0 F0982759 F17EE300 D48FC2D5
               DC854C10 523898A9 C03A0F89 47D6CD88

(i=5)  v[16] = C4AA2DDB 111343A3 D54A700A 574A00A9 857D5A48 B1E11989
               6F5C52DF DD2C53A3 678E5F8E 9718D4E9 622CB684 92976076
               0E41A517 359DC2BE 87A87DDD 643F9CEC

(i=6)  v[16] = 3453921C D7595EE1 592E776D 3ED6A974 4D997CB3 DE9212C3
               35ADF5C9 9916FD65 96562E89 4EAD0792 EBFC2712 2385F5B2
               F34600FB D7BC20FB EB452A7B ECE1AA40

(i=7)  v[16] = BE851B2D A85F6358 81E6FC3B 0BB28000 FA55A33A 87BE1FAD
               4119370F 1E2261AA A1318FD3 F4329816 071783C2 6E536A8D
               9A81A601 E7EC80F1 ACC09948 F849A584

(i=8)  v[16] = 07E5B85A 069CC164 F9DE3141 A56F4680 9E440AD2 9AB659EA
               3C84B971 21DBD9CF 46699F8C 765257EC AF1D998C 75E4C3B6
               523878DC 30715015 397FEE81 4F1FA799

(i=9)  v[16] = 435148C4 A5AA2D11 4B354173 D543BC9E BDA2591C BF1D2569
               4FCB3120 707ADA48 565B3FDE 32C9C916 EAF4A1AB B1018F28
               8078D978 68ADE4B5 9778FDA3 2863B92E

(i=10) v[16] = D9C994AA CFEC3AA6 700D0AB2 2C38670E AF6A1F66 1D023EF3
               1D9EC27D 945357A5 3E9FFEBD 969FE811 EF485E21 A632797A
               DEEF082E AF3D80E1 4E86829B 4DEAFD3A

        h[8] = 8C5E8C50 E2147C32 A32BA7E1 2F45EB4E 208B4537 293AD69E
               4C9B994D 82596786

BLAKE3("abc") = 50 8C 5E 8C 32 7C 14 E2 E1 A7 2B A3 4E EB 45 2F
                37 45 8B 20 9E D6 3A 29 4D 99 9B 4C 86 67 59 82
]]></artwork></figure>
</section>


</back>
</rfc>
