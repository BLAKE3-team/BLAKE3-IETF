<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc>

<?rfc strict="yes" ?>
<?rfc toc="yes" ?>
<?rfc tocdepth="4" ?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="info" docName="draft-blake3-00" ipr="trust200902" submissionType="IETF">
<front>
<!--
    TODO: update date
-->
    <title>The BLAKE3 Hashing Framework</title>

    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson" role="editor">
        <organization>Taurus SA</organization>
        <address>
            <postal>
                <street>Taurus SA</street>
                <street>Place Ruth Boesiger 6</street>
                <code>1201</code>
                <city>Geneva</city>
                <country>Switzerland</country>
            </postal>
            <email>jeanphilippe.aumasson@gmail.com</email>
            <uri>https://taurushq.com</uri>
        </address>
    </author>

    <author fullname="Samuel Neves"
            initials="S" surname="Neves">
        <organization></organization>
        <address>
            <postal>
                <street></street>
                <street></street>
                <region></region> <code></code>
                <country></country>
            </postal>
            <email></email>
            <uri></uri>
        </address>
    </author>

    <author fullname="Jack O'Connor"
            initials="J" surname="O'Connor">
        <organization>SpaceX</organization>
        <address>
            <postal>
                <street>356 167th Ave NE</street>
                <region>Bellevue</region> <code>WA 98008</code>
                <country>USA</country>
            </postal>
            <email>oconnor663@gmail.com</email>
            <uri>https://jacko.io</uri>
        </address>
    </author>

    <author fullname="Zooko Wilcox-O'Hearn"
            initials="Z" surname="Wilcox-O'Hearn">
        <organization>Zcash</organization>
        <address>
            <postal>
                <street></street>
                <street></street>
                <region></region> <code></code>
                <country></country>
            </postal>
            <email></email>
            <uri></uri>
        </address>
    </author>

    <date month="March" day="28" year="2024" />

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>BLAKE3</keyword>
    <keyword>Cryptographic Hash</keyword>
    <keyword>Extendable-Output Function</keyword>
    <keyword>Key Derivation Function</keyword>
    <keyword>Pseudo-Random Function</keyword>
    <keyword>Message Authentication Code</keyword>

<abstract>
    <t> 
    This document specifies the cryptographic hashing primitive BLAKE3,
    a secure algorithm designed to be fast and highly parallelizable.
    Apart from the standard hashing functionality, BLAKE3 can serve to
    realize the following cryptographic functionalities:
    extendable-output function (XOF), key derivation function (KDF),
    pseudo-random function (PRF), and message authentication code (MAC).
    </t>
</abstract>
</front>

 <middle>

<section title="Introduction and Terminology">

    <t> 
    The <xref target="BLAKE3" /> cryptographic hash function was
    designed by Jack O'Connor, Jean-Philippe Aumasson, Samuel Neves, and
    Zooko Wilcox-O'Hearn.
    BLAKE3 is an evolution from its predecessors <xref target="BLAKE" /> and
    <xref target="BLAKE2" /><xref target="RFC7693" />. BLAKE2 is widely used in open-source
    software and in proprietary software. For example, the Linux kernel
    (from version 5.17) uses BLAKE2 in its cryptographic
    pseudorandom generator, and the WireGuard secure tunnel protocol
    uses BLAKE2 for hashing and keyed hashing. 
    </t>

    <t> 
    BLAKE3 was designed to be as secure as BLAKE2, yet considerably
    faster, thanks to 1) a compression function with a reduced number of
    rounds, and 2) a tree-based mode allowing implementations to
    leverage parallel processing. BLAKE3 was designed to take advantage
    of multi-thread and multi-core processing, as well as of
    single-instruction multiple-data (SIMD) instructions of modern
    processor architectures. 
    </t>    

    <t>
    At the time of its publication, BLAKE3 was demonstrated to be
    approximately five times faster than BLAKE2 when hashing 16 kibibyte
    messages and using a single thread. When using multiple threads and
    hashing large messages, BLAKE3 can be more than twenty times faster
    than BLAKE2.
    </t>

<section title="Hashing Modes">

    <t> 
    BLAKE3 was also designed to instantiate multiple cryptographic
    primitives, to offer a simpler and more efficient alternative to
    dedicated legacy modes and algorithms such as those in <xref
    target="RFC6234" />. These primitives include:

    <list style="hanging">
        <t hangText="Unkeyed hashing (hash):"> 
        This is the general-purpose hashing mode, taking a single input
        of arbitrary size. BLAKE3 in this mode can be used whenever a
        preimage- or collision-resistant hash function is needed, and to
        instantiate random oracles in cryptographic protocols. For
        example, BLAKE3 can replace SHA-3, as well as any SHA-2
        instance, in applications such as digital signatures.
        </t>
        <t hangText="Keyed hashing (keyed_hash):"> 
        The keyed mode takes a 32-byte key, in addition to the arbitrary
        size input. BLAKE3 in this mode can be used whenever a
        pseudorandom function (PRF) or message authentication code (MAC)
        is needed. For example, keyed BLAKE3 can replace HMAC instances.
        </t>
        <t hangText="Key derivation (derive_key):">
        The key derivation mode takes two input values, each of
        arbitrary size: a context string, and key material. BLAKE3 in
        this mode can be used whenever a key derivation function (KDF)
        is needed. For example, BLAKE3 in key derivation mode can
        replace HKDF.
        </t>
    </list>
    </t>
    <t>
    Further, all 3 modes can produce an output of arbitrary size. The
    hash mode can thus be used as an extendable-output-function (XOF);
    the keyed hash mode can thus be used as a deterministic random bit
    generator (DRBG). By default, each mode returns a 32-byte output.
    </t>
    <t>
    Applications and use cases of BLAKE3 are further discussed in
    Section 6 in <xref target="BLAKE3" />.
    </t>

</section>

<section title="Hashing Structure">

    <t>
    We provide a high-level overview of BLAKE3's internal structure, and
    introduce the associated terminology. 
    </t>

    <t>
    BLAKE3 processes input data according to a binary tree structure. It
    first splits its input into 1024-byte chunks, processing each chunk
    independently of the other chunks, using a compression function
    iterating over each of the 16 consecutive 16-byte blocks of a chunk.
    </t>
    
    <t>
    From the hash of each chunk, a binary hash tree is built to compute
    the root of the tree, which determines the BLAKE3 output.
    </t>

    <t>
    In the simplest case, there is only one chunk. In this case, this
    node is seen as the tree's root and its output determines BLAKE3's
    output. If the number of chunks is a power of 2, the binary tree is
    a complete tree and all leaves are at the same level. If the number
    of chunks is not a power of 2, not all chunks will be at the same
    level (or layer) of the tree.
    </t>

</section>
</section>

<!-- **************************************************   -->

<section title="Conventions and Constants" anchor="conventions">

    <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
    document are to be interpreted as described in <xref target="RFC2119" />.
    </t>

<section title="Arithmetic Notation">

    <t> 
    For real-valued x we define the following functions:
    <list style="hanging">
        <t hangText="   floor(x)">
            Floor, the largest integer less than or equal to x.
        </t>
        <t hangText="    ceil(x)">
            Ceiling, the smallest integer greater than or equal to x.
        </t>
        <t hangText="    frac(x)">
            Positive fractional part of x, frac(x) = x - floor(x).
        </t>
    </list>
    </t>

    <t> 
    Operator notation in pseudocode:
    <list style="hanging">
        <t hangText="     2**n =">
            2 to the power "n". 2**0=1, 2**1=2, 2**2=4, 2**3=8, etc.
        </t>

        <t hangText="    a ^ b =">
            Bitwise exclusive-or operation between "a" and "b".
        </t>
        <t hangText="  a mod b =">
            Remainder "a" modulo "b", always in range [0, b-1].
        </t>
        <t hangText="   x >> n =">
            floor(x / 2**n). Logical shift "x" right by "n" bits.
        </t>
        <t hangText="   x &lt;&lt; n =">
            (x * 2**n) mod (2**w). Logical shift "x" left by "n".
        </t>
        <t hangText="  x >>> n ="> (x >> n) ^ (x &lt;&lt; (w - n)).
            Rotate "x" right by "n".
        </t>
    </list>
    </t>

</section>


<section title="Little-Endian Convention">

    <t>
    BLAKE3 performs operations on 32-bit words, and on arrays of
    words. Array indexing is zero-based; the first element of an
    n-element array "v" is v[0] and the last one is v[n - 1]. All
    elements is denoted by v[0..n-1].
    </t>

    <t>
    Byte (octet) streams are interpreted as words in little-endian
    order, with the least significant byte first.  Consider this
    sequence of eight hexadecimal bytes:
    </t>

    <figure>
    <artwork>
    <![CDATA[
        x = 0x01 0x23 0x45 0x67 0x89 0xab 0xcd 0xef
    ]]>
    </artwork>
    </figure>

    <t>
    When interpreted as a 32-bit word from the beginning memory address,
    x contains two 32-bit words x[0] and x[1], respectively equal to
    0x67452301 and 0xefcdab89 in hexadecimal, or 1732584193 and
    4023233417 in decimal.
    </t>

</section>


<section title="Initial Value (IV)">


    <t>
    The initial value (IV) of BLAKE3 is the same as SHA-256 IV,
    namely the 8-word IV[0..7]: <xref target="RFC6234" />.
    </t> 

    <figure>
    <artwork type='text/ascii-art'>
      0x6a09e667
      0xbb67ae85
      0x3c6ef372
      0xa54ff53a
      0x510e527f
      0x9b05688c
      0x1f83d9ab
      0x5be0cd19
    </artwork>
    </figure>

    <t>
    This IV is set to the initial chaining value of BLAKE3 when no key
    is used. Otherwise the 256-bit key is set as the initial chaining
    value.
    </t>

    <t>This IV is also used as part of the compression function, where
    the first four words, IV[0..3] are copied into the 16-word local
    initial state, at positions v[8..11].
    </t>

</section>

<section title="Message Word Permutation" anchor="permutation">

    <t>
    BLAKE3 uses a permutation of the 16 indices (0 to 15). This
    permutation must be following one, where the second line shows the
    index of the word move to the position indexed on the first line: 
    </t>

    <figure>
    <artwork type='text/ascii-art'>
    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15
    2,  6,  3, 10,  7,  0,  4, 13,  1, 11, 12,  5,  9, 14, 15,  8
    </artwork>
    </figure>

    <t>
    For example, after applying the permutation to an array v[0..15]
    consisting of elements v[0], v[1], ..., v[15], the permuted array
    shall consist of v[2] at the first position, v[6] at the second
    position, and so on.
    </t>

</section>

<section title="Compression Function Flags" anchor="flags">

    <t>
        The compression function of BLAKE3 uses a set of flags to
        control various aspects of its operation. These flags are
        defined as follows: 
    </t>
    <t>
    <list style="hanging">
        <t hangText="CHUNK_START (0x01):">
        This flag must set for the first block of each chunk, and only
        for this block.
        </t>

        <t hangText="CHUNK_END (0x02):">
        This flag signals the end of the chunk.  It must be set for the
        compression function of the last block within a chunk, and only
        for this block. If a chunk contains only one block, that block
        must set both CHUNK_START and CHUNK_END.
        </t>

        <t hangText="PARENT (0x04):">
        In the binary tree structure, this flag must be set on parent
        nodes (non-chunk nodes), and only for parent nodes. It signals
        that the node combines the 32-byte outputs of nodes in the tree
        (chunks of parents). A parent node always processes exactly 64
        bytes, that is, the concatenation of two 32-byte output values
        from a child node.
        </t>

        <t hangText="ROOT (0x08):">
        This flag must be set to the final compression in the tree,
        representing the root, and only for such nodes. The root node
        may be a parent node, but may also be the last compression of a
        chunk processing leaf (if there is a single chunk). In this
        latter case, only the last compression function sets the ROOT
        flag. In the case of a parent node, there is a single
        compression function, which sets the ROOT flag.
        </t>
        
        <t hangText="KEYED_HASH (0x10):">
        This flag must be set to all compression functions when using BLAKE3
        in the keyed_hash mode, and only in this mode. In this mode, a
        256-bit key must be used as initial chaining value instead of
        IV.
        </t>

        <t hangText="DERIVE_KEY_CONTEXT (0x20) and DERIVE_KEY_MATERIAL
        (0x40):">
        These flags are used in BLAKE3's derive_key mode, where the
        context string is first hashed by a (non-keyed) BLAKE3
        instance must set the DERIVE_KEY_CONTEXT to all compression
        functions; the 32-byte output is then used as the key of a
        keyed BLAKE3 instance hashing the key material, which must set 
        DERIVE_KEY_MATERIAL (but not DERIVE_KEY_CONTEXT) to all
        compression functions.</t>
    </list>
    </t>

    <t>
    If two or more flags are set, then all their respective bits shall
    appear in the flags compression function input. This combination may
    be implemented as an XOR or integer addition between the flags. For
    example, if CHUNK_START and KEYED_HASH are set, then the flags input
    word will be the 32-bit word 0x00000011, where 0x11 = 0x10 + 0x01 =
    0x10 ^ 0x01.
    </t>
</section>
    


</section>

<!-- **************************************************   -->

<section anchor="compression" title="Compression Function">

    <t>
    BLAKE3 uses the compression function when processing chunks, when
    computing parent nodes within its tree, and when producing output
    bytes from the root node(s).
    </t>

<section title="Compression Function Input Values">

    <t>These variables are used in the algorithm description.
    <list style="hanging">
        <t hangText="    h[0..7]">
        The hash chaining value, 8 words of 32 bits.
        </t>
        <t hangText="   m[0..15]">
        The message block processed, 16 words of 32 bits.
        </t>
        <t hangText="    t[0..1]">
        A 64-bit counter whose lower-order 32-bit word is t[0] and
        higher-order 32-bit word is t[1].
        </t>
        <t hangText="        len">
        32-bit word encoding the number of application data bytes in
        the block, at least 1 and at most 64. That is, len is equal to
        64 minus the number of padding bytes, which are set to
        zero (0x00).
        </t>
        <t hangText="      flags">
        32-bit word encoding the flags defined for a given compression
        function call, see <xref target="flags" />.
        </t>
    </list>
    </t>
<figure><artwork><![CDATA[
]]></artwork></figure>
</section>

<section title="Quarter-Round Function G">

    <t>
    The G function mixes two input words x and y into four
    words indexed by a, b, c, and d in the working array v[0..15]. The
    full modified array is returned. 
    </t>

    <figure>
    <artwork>
    <![CDATA[
        FUNCTION G( v[0..15], a, b, c, d, x, y )
        |
        |   v[a] := (v[a] + v[b] + x) mod 2**32
        |   v[d] := (v[d] ^ v[a]) >>> 16
        |   v[c] := (v[c] + v[d])     mod 2**32
        |   v[b] := (v[b] ^ v[c]) >>> 12
        |   v[a] := (v[a] + v[b] + y) mod 2**32
        |   v[d] := (v[d] ^ v[a]) >>> 8 
        |   v[c] := (v[c] + v[d])     mod 2**32
        |   v[b] := (v[b] ^ v[c]) >>> 7 
        |
        |   RETURN v[0..15]
        |
        END FUNCTION.
    ]]>
    </artwork>
    </figure>
</section>

<section title="Compression Function Processing">

    <t>
    BLAKE3's compression function takes as input an 8-word state h, a
    16-word message m, a 2-word counter t, a data length word len, and a
    word flags (as a bit field encoding flags).
    </t>

    <t>
    BLAKE3's compression must do exactly 7 rounds, which are numbered 0
    to 6 in the pseudocode below. Each round includes 8 calls to the G
    function.  
    </t>

    <figure>
    <artwork>
    <![CDATA[
    FUNCTION BLAKE3_COMPRESS( h[0..7], m[0..15], t, len, flags )
    |
    |   // Initialize local 16-word array v[0..15]
    |   v[0..7] := h[0..7]              // First half from state.
    |   v[8..11] := IV[0..3]            // Second half from IV.
    |
    |   v[12] :=  t[0]                  // Low word of the counter.
    |   v[13] :=  t[1]                  // High word of the counter.
    |   v[14] :=  len                   // Application data length.
    |   v[15] :=  flags                 // Flags.
    |
    |   // Cryptographic mixing
    |   FOR i = 0 TO 6 DO               // 7 rounds.
    |   |
    |   |   v := G( v, 0, 4,  8, 12, m[ 0], m[ 1] )
    |   |   v := G( v, 1, 5,  9, 13, m[ 2], m[ 3] )
    |   |   v := G( v, 2, 6, 10, 14, m[ 4], m[ 5] )
    |   |   v := G( v, 3, 7, 11, 15, m[ 6], m[ 7] )
    |   |
    |   |   v := G( v, 0, 5, 10, 15, m[ 8], m[ 9] )
    |   |   v := G( v, 1, 6, 11, 12, m[10], m[11] )
    |   |   v := G( v, 2, 7,  8, 13, m[12], m[13] )
    |   |   v := G( v, 3, 4,  9, 14, m[15], m[15] )
    |   |
    |   |   PERMUTE(m)                  // Apply the permutation.
    |   |
    |   END FOR
    |
    |   // Compute the output state (untruncated)
    |   FOR i = 0 TO 7 DO 
    |   |   v[i] := v[i] ^ v[i + 8] 
    |   |   v[i + 8] := v[i + 8] ^ h[i] 
    |   END FOR.
    |
    |   RETURN v
    |
    END FUNCTION.
    ]]>
    </artwork>
    </figure>

    <t>
    When processing chunks or computing parent nodes, the output is
    always truncated to the first 8 words v[0..7]. When computing the
    output value, all the 16 words may be used (see <xref target="xof"
    />).
    </t>


</section>
</section>

<!-- **************************************************   -->

<section anchor="treemode" title="Tree Mode of Operation">

    <t>The following describes BLAKE3's tree mode of operation, first
    specifying the processing of input data as chunks in <xref
    target="chunkspro" />, then describing how the binary hash tree structure is
    formed for a given number of chunks in <xref target="treepro" />.
    Finally, <xref target="xof" /> describes how BLAKE3 can produce an
    output of arbitrary length without committing to a length when
    starting processing data.
    </t>

<section anchor="chunkspro" title="Chunk Processing">

    <t>
        BLAKE3's chunk processing divides the BLAKE3 input into
        1024-byte chunks, which will be leaves of a binary tree. The
        last chunk will be of less than 1024 bytes if the message byte
        length is not a multiple of 1024.
    </t>
    <t>
        Chunks are divided into 64-byte blocks. The last block of
        the last chunk may be shorter, but not empty, unless the entire
        input is empty. If necessary, the last block is padded with
        zeros to be 64-byte.
    </t>
    <t> 
        Each chunk is processed by iterating the compression function
        (1024/64 = 16 times for a full 1024-byte chunk) to process
        64-byte blocks, each parsed as 16 32-bit little-endian words.
        The output of each compression function is h[0..7], the 8-word
        truncated output, which is the input of the next compression
        function (and the output of the chunk processing for the last
        compression function call).
    </t>
    <t>
    Compression function input arguments are set as follows: 
    <list style="hanging">
        <t hangText="    h[0..7]">
        For the first block of a chunk, this is set either to the key,
        or to the IV if no key is defined. For subsequent block, h is
        set to the output of the previous block's compression.
        </t>
        <t hangText="   m[0..15]">
        This is the block processed by the compression function.
        </t>
        <t hangText="    t[0..1]">
        The counter t for each block is the chunk index, that is, 0 for
        all blocks in the first chunk, 1 for all blocks in the second
        chunk, and so on.
        </t>
        <t hangText="        len">
        The block length is set to 64 for all blocks except the last
        block of a chunk, where it is the number of data bytes (thus
        excluding padding zeros.)
        </t>
        <t hangText="       flag">
        The first block of each chunk sets the CHUNK_START flag (cf.
        Table 3), and the last block of each chunk sets the CHUNK_END
        flag. If a chunk contains only one block, that block sets both
        CHUNK_START and CHUNK_END. If a chunk is the root of its tree,
        the last block of that chunk also sets the ROOT flag. Multiple
        flags may thus be set.
        </t>
    </list>
    </t>
    <t>
    Flags are set as specified in <xref target="flags" />.  More than
    one flag may be set, for example the first compression of the first
    chunk will have CHUNK_START and KEYED_HASH set. If a chunk is only
    64-byte, then its only compression will in addition have the
    CHUNK_END flag set. 
    </t>

</section>

<section anchor="treepro" title="Binary Tree Processing">

    <t>
    From the chunk processing of input data, BLAKE3 computes its output
    following a binary hash tree (a.k.a. Merkle tree) structure. Parent
    nodes process 64-byte messages that consist of the concatenation of
    two 32-byte hash values from child nodes (chunk nodes of other
    parent nodes). Processing such a 64-byte message requires only one
    call to the compression function.
    </t>
    <t>
    The compression function used by parent nodes thus uses the
    following arguments:
    <list style="hanging">
        <t hangText="    h[0..7]">
        This is set either to the key (in keyed_hash mode), and to the
        IV otherwise. 
        </t>
        <t hangText="   m[0..15]">
        This is the 64-byte block consisting in the concatenated 32-byte
        output of the two child nodes.
        </t>
        <t hangText="    t[0..1]">
        The counter t is set to zero (0).
        </t>
        <t hangText="        len">
        The block length is set to 64.
        </t>
        <t hangText="       flag">
        The PARENT flag is set for all parent nodes. If a parent is the
        root of the tree, then it also sets the ROOT flag (and keeps the
        PARENT flag). Parent nodes never set CHUNK_START and CHUNK_END.
        The mode flags (KEYED_HASH, DERIVE_KEY_CONTEXT,
        DERIVE_KEY_MATERIAL) must be set for a parent node when
        operating if the respective modes. 
        </t>
    </list>
    </t>
    <t>
    When the number of chunks is not a power of 2 (that is, when the
    binary tree is not complete), the tree structure is created
    according to the following rules:
    <list style="symbols">
        <t>
        If there is only one chunk, that chunk is the root node and only
        node of the tree. Otherwise, the chunks are assembled with
        parent nodes, each parent node having exactly two children.
        </t>
        <t>
        Left subtrees are full, that is, each left subtree is a complete binary
        tree, with all its chunks at the same depth, and a number of
        chunks that is a power of 2.
        </t>
        <t>
        Left subtrees are big, that is, each left subtree contains a
        number of chunks greater than or equal to the number of chunks
        in its sibling right subtree.
        </t>
    </list>
    </t>
    <t>
    The implementation of this logic, especially regarding the
    assignment of a chunk to a position in the tree, is discussed in
    <xref target="impl" />.
    </t>
    <t>
    The root of the tree determines the final hash output. By default,
    the BLAKE3 output is the 32-byte output of the root node (that is,
    the final values of v[0..7] in the compression function). Output of
    up to 64 bytes is formed by taking as many bytes as required from
    the final v[0..15] of the root's compression function. See <xref
    target="xof" /> for the case of output values larger than 64 bytes.
    </t>

</section>

<section anchor="xof" title="Extendable Output">

    <t>
    BLAKE3, in any of its three modes, can produce outputs of any byte
    length up to 2**64 - 1. This is done by repeating the root
    compression with incrementing values of the counter t. The results
    of these repeated root compressions are then concatenated to form
    the output.
    </t>

</section>

</section>


<!-- **************************************************   -->

<section anchor="impl" title="Implementation Considerations">

    <t>
    Detailed implementation and optimization guidelines are given in
    Section 5 of <xref target="BLAKE3" />. This section providers a
    brief overview of these, as a starting point to implementers,
    covering the most salient points.
    </t>

<section title="Incremental Hashing Implementation">

    <t>
    BLAKE3 may be implemented using an application programming interface
    (API) allowing for incremental hashing, that is, where the caller
    provides input data via multiple repeated calls to an "update"
    function, as opposed to a single call providing all the input data.
    Such an API typically consists of an "init" function call to
    initialize an internal context state, followed by a series of
    "update" function calls, eventually followed by a "finalize"
    function call that that returns the output.
    </t>

    <t>
    To implement incremental hashing, an implementation must maintain an
    internal state, which must keep track of the state of the current
    chunk (if any) and of chaining values of the tree in formation. A
    stack data structure may be used for this purpose, as proposed in
    Section 5.1 of <xref target="BLAKE3" />.
    </t>

</section>


<section title="Compression Function Implementation">

    <t>
    In the compression function, the first four calls to G may be
    computed in parallel. Likewise, the last four calls to G may be
    computed in parallel. A parallel implementation of the compression
    function may leverage single-instruction multiple-date (SIMD)
    processing, as described in Section 5.3 of <xref target="BLAKE3" />.
    </t>

    <t>
    The permutation of words may be implemented by pre-computing the
    indices corresponding to 0, 1, 2, ..., 7 iterations of the
    permutation, and then applying each of these 7 permutations to the
    initial message at each of the 7 rounds. These 7 permutations would
    then be:
    </t>

    <figure>
    <artwork type='text/ascii-art'>
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15
     2,  6,  3, 10,  7,  0,  4, 13,  1, 11, 12,  5,  9, 14, 15,  8
     3,  4, 10, 12, 13,  2,  7, 14,  6,  5,  9,  0, 11, 15,  8,  1
    10,  7, 12,  9, 14,  3, 13, 15,  4,  0, 11,  2,  5,  8,  1,  6
    12, 13,  9, 11, 15, 10, 14,  8,  7,  2,  5,  3,  0,  1,  6,  4
     9, 14, 11,  5,  8, 12, 15,  1, 13,  3,  0, 10,  2,  6,  4,  7
    11, 15,  5,  0,  1,  9,  8,  6, 14, 10,  2, 12,  3,  4,  7, 13
    </artwork>
    </figure>

</section>

<section title="Multi-Thread Implementation">

    <t>
    In addition to the potential parallel computing of the compression
    function internals via SIMD processing, BLAKE3 can benefit from
    multi-threaded software implementation. Different approaches may be
    implemented, the performance-optimal one depending on the expected
    input data length. Section 5.2 in <xref target="BLAKE3" /> provides
    further guidelines to implementers.
    </t>

</section>

<section title="Extendable Output Implementation">

    <t>
    Because the repeated root compressions differ only in the value of
    t, the implementation can execute any number of them in parallel.
    The caller can also adjust t to seek to any point in the output
    stream. For example, computing the third 64-byte block of output
    (that is, the last 64 bytes of a 192-byte output) does not require
    the computation of the first 128 bytes.  
    </t>

    <t>
    BLAKE3 does not domain separate outputs of different lengths:
    shorter outputs are prefixes of longer ones. The caller can extract
    as much output as needed, without knowing the final length in
    advance.
    </t>

</section>

</section>



<section anchor="IANA" title="IANA Considerations">

    <t>
    This memo includes no request to IANA at the moment, but may in
    further versions of this I-D.
    </t>

</section>

<section anchor="Security" title="Security Considerations">

    <t> 
    BLAKE3 with an output of at least 32 bytes targets a security level
    of at least 128 bits for all its security goals. BLAKE3 may be used
    in any of the modes described in this document to provide
    cryptographically secure hashing functionality. BLAKE3 must not be
    used as a password-based hash function or password-based key
    derivation function, functionalities for which dedicated algorithms
    must be used, such as Argon2 as defined in <xref target="RFC9106" />.
    </t>

    <t>
    We refer the reader to <xref target="BLAKE3" /> for detailed
    cryptographic rationale and security analysis of BLAKE3.
    </t>

</section>

</middle>
<back>

<references title="Informative References">

<reference anchor="BLAKE3" target="https://github.com/BLAKE3-team/BLAKE3">
    <front>
    <title>BLAKE3</title>
    <author fullname="Jack O'Connor"
            initials="J" surname="O'Connor" />
    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson"  />
    <author fullname="Samuel Neves"
            initials="S" surname="Neves" />
    <author fullname="Zooko Wilcox-O'Hearn"
            initials="Z" surname="Wilcox-O'Hearn" />
    <date month="January" year="2020" />
    </front>
</reference>

<reference anchor="BLAKE2" target="https://www.blake2.net/">
    <front>
    <title>BLAKE2: simpler, smaller, fast as MD5</title>
    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson"  />
    <author fullname="Samuel Neves"
            initials="S" surname="Neves" />
    <author fullname="Zooko Wilcox-O'Hearn"
            initials="Z" surname="Wilcox-O'Hearn" />
    <author fullname="Christian Winnerlein"
            initials="C" surname="Winnerlein" />
    <date month="January" year="2013" />
    </front>
</reference>

<reference anchor="BLAKE" target="https://aumasson.jp/blake/">
    <front>
    <title>The Hash Function BLAKE</title>
    <author fullname="Jean-Philippe Aumasson"
            initials="J-P" surname="Aumasson" />
    <author fullname="Willi Meier"
            initials="W" surname="Meier" />
    <author fullname="Raphael C.-W. Phan"
            initials="R C-W" surname="Phan" />
    <author fullname="Luca Henzen"
            initials="L" surname="Henzen" />
    <date month="October" year="2008" />
    </front>
</reference>

<reference anchor="RFC9106">
    <front>
    <title>
    Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications
    </title>
    <author fullname="Alex Biryukov" initials="A-B" surname="Biryukov" />
    <author fullname="Daniel Dinu" initials="D-D" surname="Dinu" />
    <author fullname="Dmitry Khovratovich" initials="D-K" surname="Khovratovich" />
    <author fullname="Simon Josesson" initials="S-J" surname="Josefsson" />
    <date month="September" year="2021" />
    </front>
    <seriesInfo name="RFC" value="9106" />
</reference>

<reference anchor="RFC7693">
    <front>
    <title> The BLAKE2 Cryptographic Hash and Message Authentication
    Code (MAC)</title>
    <author fullname="Markku-Juhani O. Saarinen" initials="M-J" surname="Saarinen" />
    <author fullname="Jean-Philippe Aumasson" initials="J-P"
    surname="Aumasson" />
    <date month="November" year="2015" />
    </front>
    <seriesInfo name="RFC" value="7693" />
</reference>

<reference anchor="RFC2119">
    <front>
    <title>Key words for use in RFCs to Indicate Requirement Levels</title>
    <author fullname="Scott Bradner" initials="S" surname="Bradner" />
    <date month="March" year="1997" />
    </front>
    <seriesInfo name="RFC" value="2119" />
    <seriesInfo name="BCP" value="14" />
</reference>

<reference anchor="RFC6234">
    <front>
    <title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
    <author fullname="Donald Eastlake" initials="D" surname="Eastlake" />
    <author fullname="Tony Hansen" initials="T" surname="Hansen" />
    <date month="May" year="2011" />
    </front>
    <seriesInfo name="RFC" value="6234" />
</reference>

</references>

<section title="BLAKE3 Implementations" anchor="b3src">

    <t>
    Reference implementations of BLAKE3 in the C and Rust languages are
    available online at <eref
    target="https://github.com/BLAKE3-team/BLAKE3/" />. These
    implementations include parallel implementations leveraging
    multi-threading and different SIMD processing technologies.
    </t>

    <t>
    For the sake of document size, these implementations are not copied
    into the present document. However, they are expected to remain
    permanently available, for the foreseeable future.
    </t>

</section>

<section title="Example of BLAKE3 Computation" anchor="b3test">

<t> 
    TODO: Give examples of intermediate/final values for 1) the compression function,
    and 2) for each of the modes
</t>

<figure><artwork><![CDATA[
       m[16] = 00636261 00000000 00000000 00000000 00000000 00000000
               00000000 00000000 00000000 00000000 00000000 00000000
               00000000 00000000 00000000 00000000

(i=0)  v[16] = 6B08E647 BB67AE85 3C6EF372 A54FF53A 510E527F 9B05688C
               1F83D9AB 5BE0CD19 6A09E667 BB67AE85 3C6EF372 A54FF53A
               510E527C 9B05688C E07C2654 5BE0CD19

(i=1)  v[16] = 16A3242E D7B5E238 CE8CE24B 927AEDE1 A7B430D9 93A4A14E
               A44E7C31 41D4759B 95BF33D3 9A99C181 608A3A6B B666383E
               7A8DD50F BE378ED7 353D1EE6 3BB44C6B

(i=2)  v[16] = 3AE30FE3 0982A96B E88185B4 3E339B16 F24338CD 0E66D326
               E005ED0C D591A277 180B1F3A FCF43914 30DB62D6 4847831C
               7F00C58E FB847886 C544E836 524AB0E2

(i=3)  v[16] = 7A3BE783 997546C1 D45246DF EDB5F821 7F98A742 10E864E2
               D4AB70D0 C63CB1AB 6038DA9E 414594B0 F2C218B5 8DA0DCB7
               D7CD7AF5 AB4909DF 85031A52 C4EDFC98

(i=4)  v[16] = 2A8B8CB7 1ACA82B2 14045D7F CC7258ED 383CF67C E090E7F9
               3025D276 57D04DE4 994BACF0 F0982759 F17EE300 D48FC2D5
               DC854C10 523898A9 C03A0F89 47D6CD88

(i=5)  v[16] = C4AA2DDB 111343A3 D54A700A 574A00A9 857D5A48 B1E11989
               6F5C52DF DD2C53A3 678E5F8E 9718D4E9 622CB684 92976076
               0E41A517 359DC2BE 87A87DDD 643F9CEC

(i=6)  v[16] = 3453921C D7595EE1 592E776D 3ED6A974 4D997CB3 DE9212C3
               35ADF5C9 9916FD65 96562E89 4EAD0792 EBFC2712 2385F5B2
               F34600FB D7BC20FB EB452A7B ECE1AA40

(i=7)  v[16] = BE851B2D A85F6358 81E6FC3B 0BB28000 FA55A33A 87BE1FAD
               4119370F 1E2261AA A1318FD3 F4329816 071783C2 6E536A8D
               9A81A601 E7EC80F1 ACC09948 F849A584

(i=8)  v[16] = 07E5B85A 069CC164 F9DE3141 A56F4680 9E440AD2 9AB659EA
               3C84B971 21DBD9CF 46699F8C 765257EC AF1D998C 75E4C3B6
               523878DC 30715015 397FEE81 4F1FA799

(i=9)  v[16] = 435148C4 A5AA2D11 4B354173 D543BC9E BDA2591C BF1D2569
               4FCB3120 707ADA48 565B3FDE 32C9C916 EAF4A1AB B1018F28
               8078D978 68ADE4B5 9778FDA3 2863B92E

(i=10) v[16] = D9C994AA CFEC3AA6 700D0AB2 2C38670E AF6A1F66 1D023EF3
               1D9EC27D 945357A5 3E9FFEBD 969FE811 EF485E21 A632797A
               DEEF082E AF3D80E1 4E86829B 4DEAFD3A

        h[8] = 8C5E8C50 E2147C32 A32BA7E1 2F45EB4E 208B4537 293AD69E
               4C9B994D 82596786

BLAKE3("abc") = 50 8C 5E 8C 32 7C 14 E2 E1 A7 2B A3 4E EB 45 2F
                37 45 8B 20 9E D6 3A 29 4D 99 9B 4C 86 67 59 82
]]></artwork></figure>
</section>


</back>
</rfc>
