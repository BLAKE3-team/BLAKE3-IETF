



Internet Engineering Task Force                       J-P. Aumasson, Ed.
Internet-Draft                                                 Taurus SA
Intended status: Informational                                  S. Neves
Expires: 29 September 2024                                              
                                                             J. O'Connor
                                                                  SpaceX
                                                       Z. Wilcox-O'Hearn
                                                                   Zcash
                                                           28 March 2024


                      The BLAKE3 Hashing Framework
                            draft-blake3-00

Abstract

   This document specifies the cryptographic hashing primitive BLAKE3, a
   secure algorithm designed to be fast and highly parallelizable.
   Apart from the standard hashing functionality, BLAKE3 can serve to
   realize the following cryptographic functionalities: extendable-
   output function (XOF), key derivation function (KDF), pseudo-random
   function (PRF), and message authentication code (MAC).

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 29 September 2024.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.



Aumasson, et al.        Expires 29 September 2024               [Page 1]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction and Terminology  . . . . . . . . . . . . . . . .   2
     1.1.  Hashing Modes . . . . . . . . . . . . . . . . . . . . . .   3
     1.2.  Hashing Structure . . . . . . . . . . . . . . . . . . . .   3
   2.  Conventions and Constants . . . . . . . . . . . . . . . . . .   4
     2.1.  Arithmetic Notation . . . . . . . . . . . . . . . . . . .   4
     2.2.  Little-Endian Convention  . . . . . . . . . . . . . . . .   5
     2.3.  Initial Value (IV)  . . . . . . . . . . . . . . . . . . .   5
     2.4.  Message Word Permutation  . . . . . . . . . . . . . . . .   5
     2.5.  Compression Function Flags  . . . . . . . . . . . . . . .   6
   3.  Compression Function  . . . . . . . . . . . . . . . . . . . .   7
     3.1.  Compression Function Input Values . . . . . . . . . . . .   7
     3.2.  Quarter-Round Function G  . . . . . . . . . . . . . . . .   7
     3.3.  Compression Function Processing . . . . . . . . . . . . .   8
   4.  Tree Mode of Operation  . . . . . . . . . . . . . . . . . . .  10
     4.1.  Chunk Processing  . . . . . . . . . . . . . . . . . . . .  10
     4.2.  Binary Tree Processing  . . . . . . . . . . . . . . . . .  11
     4.3.  Extendable Output . . . . . . . . . . . . . . . . . . . .  11
   5.  Applications  . . . . . . . . . . . . . . . . . . . . . . . .  11
   6.  Implementation Considerations . . . . . . . . . . . . . . . .  11
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  12
   9.  Informative References  . . . . . . . . . . . . . . . . . . .  12
   Appendix A.  BLAKE3 Implementations . . . . . . . . . . . . . . .  12
   Appendix B.  Example of BLAKE3 Computation  . . . . . . . . . . .  13
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  14

1.  Introduction and Terminology

   The [BLAKE3] cryptographic hash function was designed by Jack
   O'Connor, Jean-Philippe Aumasson, Samuel Neves, and Zooko Wilcox-
   O'Hearn.  BLAKE3 is an evolution from its predecessors [BLAKE] and
   [BLAKE2][RFC7693].  BLAKE2 is widely used in open-source software and
   in proprietary software.  For example, the Linux kernel (from version
   5.17) uses BLAKE2 in its cryptographic pseudorandom generator, and
   the WireGuard secure tunnel protocol uses BLAKE2 for hashing and
   keyed hashing.

   BLAKE3 was designed to be as secure as BLAKE2, yet considerably
   faster, thanks to 1) a compression function with a reduced number of
   rounds, and 2) a tree-based mode allowing implementations to leverage



Aumasson, et al.        Expires 29 September 2024               [Page 2]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


   parallel processing.  BLAKE3 was designed to take advantage of multi-
   thread and multi-core processing, as well as of single-instruction
   multiple-data (SIMD) instructions of modern processor architectures.

   At the time of its publication, BLAKE3 was demonstrated to be
   approximately five times faster than BLAKE2 when hashing 16 kibibyte
   messages and using a single thread.  When using multiple threads and
   hashing large messages, BLAKE3 can be more than twenty times faster
   than BLAKE2.

1.1.  Hashing Modes

   BLAKE3 was also designed to instantiate multiple cryptographic
   primitives, to offer a simpler and more efficient alternative to
   dedicated legacy modes and algorithms such as those in [RFC6234].
   These primitives include:

   Unkeyed hashing (hash):  This is the general-purpose hashing mode,
      taking a single input of arbitrary size.  BLAKE3 in this mode can
      be used whenever a preimage- or collision-resistant hash function
      is needed, and to instantiate random oracles in cryptographic
      protocols.  For example, BLAKE3 can replace SHA-3, as well as any
      SHA-2 instance.

   Keyed hashing (keyed_hash):  The keyed mode takes a 32-byte key, in
      addition to the arbitrary size input.  BLAKE3 in this mode can be
      used whenever a pseudorandom function (PRF) or message
      authentication code (MAC) is needed.  For example, keyed BLAKE3
      can replace HMAC.

   Key derivation (derive_key):  The key derivation mode takes two input
      values, each of arbitrary size: a context string, and key
      material.  BLAKE3 in this mode can be used whenever a key
      derviation function (KDF) is needed.  For example, BLAKE3 in key
      derivation mode can replace HKDF.

   Further, all 3 modes can produce an output of arbitrary size.  The
   hash mode can thus be used as an extendable-output-function (XOF);
   the keyed hash mode can thus be used as a deterministic random bit
   generator (DRBG).  By default, each mode returns a 32-byte output.

1.2.  Hashing Structure

   We provide a high-level overview of BLAKE3's internal structure, and
   introduce the associated terminology.






Aumasson, et al.        Expires 29 September 2024               [Page 3]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


   BLAKE3 processes input data according to a binary tree structure.  It
   first splits its input into 1024-byte chunks, processing each chunk
   independently of the other chunks, using a compression function
   iterating over each of the 16 consecutive 16-byte blocks of a chunk.

   From the hash of each chunk, a binary hash tree is built to compute
   the root of the tree, which determines the BLAKE3 output.

   In the simplest case, there is only one chunk.  In this case, this
   node is seen as the tree's root and its output determines BLAKE3's
   output.  If the number of chunks is a power of 2, the binary tree is
   a complete tree and all leaves are at the same level.  If the number
   of chunks is not a power of 2, not all chunks will be at the same
   level (or layer) of the tree.

2.  Conventions and Constants

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

2.1.  Arithmetic Notation

   For real-valued x we define the following functions:

   floor(x)  Floor, the largest integer less than or equal to x.

   ceil(x)  Ceiling, the smallest integer greater than or equal to x.

   frac(x)  Positive fractional part of x, frac(x) = x - floor(x).

   Operator notation in pseudocode:

   2**n =  2 to the power "n". 2**0=1, 2**1=2, 2**2=4, 2**3=8, etc.

   a ^ b =  Bitwise exclusive-or operation between "a" and "b".

   a mod b =  Remainder "a" modulo "b", always in range [0, b-1].

   x >> n =  floor(x / 2**n).  Logical shift "x" right by "n" bits.

   x << n =  (x * 2**n) mod (2**w).  Logical shift "x" left by "n".

   x >>> n =  (x >> n) ^ (x << (w - n)).  Rotate "x" right by "n".







Aumasson, et al.        Expires 29 September 2024               [Page 4]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


2.2.  Little-Endian Convention

   BLAKE3 performs operations on 32-bit words, and on arrays of words.
   Array indexing is zero-based; the first element of an n-element array
   "v" is v[0] and the last one is v[n - 1].  All elements is denoted by
   v[0..n-1].

   Byte (octet) streams are interpreted as words in little-endian order,
   with the least significant byte first.  Consider this sequence of
   eight hexadecimal bytes:


           x = 0x01 0x23 0x45 0x67 0x89 0xab 0xcd 0xef


   When interpreted as a 32-bit word from the beginning memory address,
   x contains two 32-bit words x[0] and x[1], respectively equal to
   0x67452301 and 0xefcdab89 in hexadecimal, or 1732584193 and
   4023233417 in decimal.

2.3.  Initial Value (IV)

   The initial value (IV) of BLAKE3 is the same as SHA-256 IV, namely
   the 8-word IV[0..7]: [RFC6234].

         0x6a09e667
         0xbb67ae85
         0x3c6ef372
         0xa54ff53a
         0x510e527f
         0x9b05688c
         0x1f83d9ab
         0x5be0cd19

   This IV is set to the initial chaining value of BLAKE3 when no key is
   used.  Otherwise the 256-bit key is set as the initial chaining
   value.

   This IV is also used as part of the compression function, where the
   first four words, IV[0..3] are copied into the 16-word local initial
   state, at positions v[8..11].

2.4.  Message Word Permutation

   BLAKE3 uses a permutation of the 16 indices (0 to 15).  This
   permutation is defined as follows, where the second line shows the
   index of the word move to the position indexed on the first line:




Aumasson, et al.        Expires 29 September 2024               [Page 5]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


       0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15
       2,  6,  3, 10,  7,  0,  4, 13,  1, 11, 12,  5,  9, 14, 15,  8

   For example, after applying the permutation to an array v[0..15]
   consisting of elements v[0], v[1], ..., v[15], the permutated array
   will consist of v[2] at the first position, v[6] at the second
   position, and so on.

2.5.  Compression Function Flags

   The compression function of BLAKE3 uses a set of flags to control
   various aspects of its operation.  These flags are defined as
   follows:

   CHUNK_START (0x01):  This flag is set for the first block of each
      chunk.

   CHUNK_END (0x02):  This flag signals the end of the chunk.  It is set
      for the compression function of the last block within a chunk.  If
      a chunk contains only one block, that block sets both CHUNK_START
      and CHUNK_END.

   PARENT (0x04):  In the binary tree structure, this flag is set on
      parent nodes (non-chunk nodes).  It signals that the node combines
      the 32-byte outputs of nodes in the tree (chunks of parents).  A
      parent node always processes exactly 64 bytes, that is, the
      concatenation of two 32-byte output values from a child node.

   ROOT (0x08):  This flag is assigned to the final node in the tree,
      representing the root.  The root node may be a parent node, but
      may also be a chunk processing leaf (if there is a single chunk).
      In this latter case, only the last compression functoin sets the
      ROOT flag.  In the case of a parent node, there is a single
      compression function, which sets the ROOT flag.

   KEYED_HASH (0x10):  This flag is set to all compression functions
      when using BLAKE3 in the keyed_hash mode.  In this mode, a 256-bit
      key is used as initial chaining value instead of IV.

   DERIVE_KEY_CONTEXT (0x20) and DERIVE_KEY_MATERIAL (0x40):  These
      flags are used in BLAKE3's derive_key mode, where the context
      string is first hashed by a (non-keyed) BLAKE3 instance setting
      the DERIVE_KEY_CONTEXT to all compression functions; the 32-byte
      output is then used as the key of a keyed BLAKE3 instance hashing
      the key material, and setting DERIVE_KEY_MATERIAL (but not
      DERIVE_KEY_CONTEXT_ to all compression functions.





Aumasson, et al.        Expires 29 September 2024               [Page 6]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


   If two or more flags are set, then all their respective bits appear
   in the flags compression function input.  This combination can be
   implemented as an XOR or integer addition between the flags.  For
   example, if CHUNK_START and KEYED_HASH are set, then the flags input
   word will be the 32-bit word 0x00000011, where 0x11 = 0x10 + 0x01.

3.  Compression Function

   BLAKE3 iterates the compression function when processing chunks

3.1.  Compression Function Input Values

   These variables are used in the algorithm description.

   h[0..7]  The hash chaining value, 8 words of 32 bits.

   m[0..15]  The message block processed, 16 words of 32 bits.

   t[0..1]  A 64-bit counter whose lower-order 32-bit word is t[0] and
      higher-order 32-bit word is t[1].

   len  32-bit word encoding the number of application data bytes in the
      block, at least 1 and at most 64.  That is, ad is equal to 64
      minus the number of padding bytes (which are set to zero).

   flags  32-bit word encoding the flags defined for a given compression
      function call, see Section 2.5.

   (Artwork only available as (unknown type): No external link
   available, see draft-blake3-00.html for artwork.)

3.2.  Quarter-Round Function G

   The G primitive function mixes two input words "x" and "y" into four
   words indexed by "a", "b", "c", and "d" in the working array
   v[0..15].  The full modified array is returned.















Aumasson, et al.        Expires 29 September 2024               [Page 7]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


       FUNCTION G( v[0..15], a, b, c, d, x, y )
       |
       |   v[a] := (v[a] + v[b] + x) mod 2**32
       |   v[d] := (v[d] ^ v[a]) >>> 16
       |   v[c] := (v[c] + v[d])     mod 2**32
       |   v[b] := (v[b] ^ v[c]) >>> 12
       |   v[a] := (v[a] + v[b] + y) mod 2**32
       |   v[d] := (v[d] ^ v[a]) >>> 8
       |   v[c] := (v[c] + v[d])     mod 2**32
       |   v[b] := (v[b] ^ v[c]) >>> 7
       |
       |   RETURN v[0..15]
       |
       END FUNCTION.

3.3.  Compression Function Processing

   BLAKE3's compression function taks as input an 8-word state h, a
   16-word message m, a 2-word counter t, a data length word len, and a
   word flags (as a bit field).

   BLAKE3's compression does 7 rounds, numbered 0 to 6.  Each round
   includes 8 calls to the G functoin.




























Aumasson, et al.        Expires 29 September 2024               [Page 8]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


       FUNCTION BLAKE3_COMPRESS( h[0..7], m[0..15], t, len, flags )
       |
       |   // Initialize local 16-word array v[0..15]
       |   v[0..7] := h[0..7]              // First half from state.
       |   v[8..11] := IV[0..3]            // Second half from IV.
       |
       |   v[12] :=  t[0]                  // Low word of the counter.
       |   v[13] :=  t[1]                  // High word of the counter.
       |   v[14] :=  len                   // Application data length.
       |   v[15] :=  flags                 // Flags.
       |
       |   // Cryptographic mixing
       |   FOR i = 0 TO 6 DO               // 7 rounds.
       |   |
       |   |   v := G( v, 0, 4,  8, 12, m[ 0], m[ 1] )
       |   |   v := G( v, 1, 5,  9, 13, m[ 2], m[ 3] )
       |   |   v := G( v, 2, 6, 10, 14, m[ 4], m[ 5] )
       |   |   v := G( v, 3, 7, 11, 15, m[ 6], m[ 7] )
       |   |
       |   |   v := G( v, 0, 5, 10, 15, m[ 8], m[ 9] )
       |   |   v := G( v, 1, 6, 11, 12, m[10], m[11] )
       |   |   v := G( v, 2, 7,  8, 13, m[12], m[13] )
       |   |   v := G( v, 3, 4,  9, 14, m[15], m[15] )
       |   |
       |   |   PERMUTE(m)                  // Apply the permutation.
       |   |
       |   END FOR
       |
       |   // Compute the output state (untruncated)
       |   FOR i = 0 TO 7 DO
       |   |   v[i] := v[i] ^ v[i + 8]
       |   |   v[i + 8] := v[i + 8] ^ h[i]
       |   END FOR.
       |
       |   RETURN v
       |
       END FUNCTION.

   When processing chunks or computing parent nodes, the output is
   always truncated to the first 8 words v[0..7].  When computing the
   output value, all the 16 words may be used (see Section 4.3).

   The permutation of words may be implemented by pre-computing the
   indices corresponding to 0, 1, 2, ..., 7 iterations of the
   permutation, and then applying each of these 7 permutations to the
   initial message at each of the 7 rounds.  These 7 permutations would
   then be:




Aumasson, et al.        Expires 29 September 2024               [Page 9]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15
        2,  6,  3, 10,  7,  0,  4, 13,  1, 11, 12,  5,  9, 14, 15,  8
        3,  4, 10, 12, 13,  2,  7, 14,  6,  5,  9,  0, 11, 15,  8,  1
       10,  7, 12,  9, 14,  3, 13, 15,  4,  0, 11,  2,  5,  8,  1,  6
       12, 13,  9, 11, 15, 10, 14,  8,  7,  2,  5,  3,  0,  1,  6,  4
        9, 14, 11,  5,  8, 12, 15,  1, 13,  3,  0, 10,  2,  6,  4,  7
       11, 15,  5,  0,  1,  9,  8,  6, 14, 10,  2, 12,  3,  4,  7, 13

4.  Tree Mode of Operation

   The following describes BLAKE3's tree mode of operation, first
   specifying the processing of input data as chunks in Section 4.1,
   then describing how the binary hash tree structure is formed for a
   given number of chunks in Section 4.2.  Finally, Section 4.3
   describes how BLAKE3 can produce an output of arbitrary length
   without committing to a length when starting processing data.

4.1.  Chunk Processing

   BLAKE3's chunk processing divides the BLAKE3 input into 1024-byte
   chunks, which will be leaves of a binary tree.  The last chunk will
   be of less than 1024 bytes if the message byte length is not a
   multiple of 1024.

   Chunks are ivided into 64-byte blocks.  The last block of the last
   chunk may be shorter, but not empty, unless the entire input is
   empty.  If necessary, the last block is padded with zeros to be
   64-byte.

   Each chunk is processed by iterating the compression function
   (1024/64 = 16 times for a full 1024-byte chunk) to process 64-byte
   blocks, each parsed as 16 32-bit little-endian words.  The output of
   each compression function is h[0..7], the 8-word truncated output,
   which is the input of the next compression function (and the output
   of the chunk processing for the last compression function call).

   Compression function input arguments are set as follows:

   h[0..7]  For the first block of a chunk, this is set either to the
      key, or to the IV if no key is defined.  For subsequent block, h
      is set to the output of the previous block's compression.

   m[0..15]  This is the block processed by the compression function.

   t[0..1]  The counter t for each block is the chunk index, that is, 0
      for all blocks in the first chunk, 1 for all blocks in the second
      chunk, and so on.




Aumasson, et al.        Expires 29 September 2024              [Page 10]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


   len  The block length is set to 64 for all blocks except the last
      block of a chunk, where it is the number of data bytes (thus
      excluding padding zeros.)

   flag  The first block of each chunk sets the CHUNK_START flag (cf.
      Table 3), and the last block of each chunk sets the CHUNK_END
      flag.  If a chunk contains only one block, that block sets both
      CHUNK_START and CHUNK_END.  If a chunk is the root of its tree,
      the last block of that chunk also sets the ROOT flag.  Multiple
      flags may thus be set.

   Flags are set as specified in Section 2.5.  More than one flag may be
   set, for example the first compression of the first chunk will have
   CHUNK_START and KEYED_HASH set.  If a chunk is only 64-byte, then its
   only compression will in addition have the CHUNK_END flag set.

4.2.  Binary Tree Processing

   BLAKE3 operates in a parallel tree mode using a binary tree
   structure.  The input data is divided into fixed-size chunks of 1024
   bytes, and each chunk is processed independently.  Chunks are then
   hashed into 256-bit (32-byte) nodes in the binary tree.

   The tree's leaves represent individual chunk hashes, and internal
   nodes are formed by hashing the concatenation of their children's
   hashes using the BLAKE3 compression function.  Each node uses a
   unique flag to indicate its position (e.g., chunk start, chunk end,
   parent, and root).

   The root of this tree represents the final hash output.  This
   approach leverages parallel processing capabilities, as each chunk
   can be processed independently and concurrently.  The use of flags in
   the compression function ensures the proper structuring and
   differentiation of tree components, maintaining the soundness of the
   hash structure.

   Describe flags, parent/root logic.

4.3.  Extendable Output

5.  Applications

   List applications similarly to the specs

6.  Implementation Considerations

   B3 impls MAY use.. parallel impl, SIMD usage, incremental hashing




Aumasson, et al.        Expires 29 September 2024              [Page 11]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


7.  IANA Considerations

   This memo includes no request to IANA.

8.  Security Considerations

   TODO: Security level summary.  Not for password hashing.  We refer
   the reader to [BLAKE3] and [BLAKE3] for detailed cryptanalytic
   rationale behind its design.

   TODO: Note on source code security (reference, no guarantees wrt side
   channels, software security, use at your own risk).

9.  Informative References

   [BLAKE]    Aumasson, J-P., Meier, W., Phan, R C-W., and L. Henzen,
              "The Hash Function BLAKE", October 2008,
              <https://aumasson.jp/blake/>.

   [BLAKE2]   Aumasson, J-P., Neves, S., Wilcox-O'Hearn, Z., and C.
              Winnerlein, "BLAKE2: simpler, smaller, fast as MD5",
              January 2013, <https://www.blake2.net/>.

   [BLAKE3]   O'Connor, J., Aumasson, J-P., Neves, S., and Z. Wilcox-
              O'Hearn, "BLAKE3", January 2020,
              <https://github.com/BLAKE3-team/BLAKE3>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", RFC 2119, BCP 14, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6234]  Eastlake, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234, May 2011,
              <https://www.rfc-editor.org/rfc/rfc6234>.

   [RFC7693]  Saarinen, M-J. and J-P. Aumasson, "The BLAKE2
              Cryptographic Hash and Message Authentication Code (MAC)",
              RFC 7693, November 2015,
              <https://www.rfc-editor.org/rfc/rfc7693>.

Appendix A.  BLAKE3 Implementations

   Cite Rust and C ref code, explain why not copied in the RFC, give git
   references, use eref https://datatracker.ietf.org/doc/html/
   rfc2629#section-2.3.1.5






Aumasson, et al.        Expires 29 September 2024              [Page 12]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


Appendix B.  Example of BLAKE3 Computation

   Give examples of intermediate/final values for 1) the compression
   function, and 2) for each of the modes

          m[16] = 00636261 00000000 00000000 00000000 00000000 00000000
                  00000000 00000000 00000000 00000000 00000000 00000000
                  00000000 00000000 00000000 00000000

   (i=0)  v[16] = 6B08E647 BB67AE85 3C6EF372 A54FF53A 510E527F 9B05688C
                  1F83D9AB 5BE0CD19 6A09E667 BB67AE85 3C6EF372 A54FF53A
                  510E527C 9B05688C E07C2654 5BE0CD19

   (i=1)  v[16] = 16A3242E D7B5E238 CE8CE24B 927AEDE1 A7B430D9 93A4A14E
                  A44E7C31 41D4759B 95BF33D3 9A99C181 608A3A6B B666383E
                  7A8DD50F BE378ED7 353D1EE6 3BB44C6B

   (i=2)  v[16] = 3AE30FE3 0982A96B E88185B4 3E339B16 F24338CD 0E66D326
                  E005ED0C D591A277 180B1F3A FCF43914 30DB62D6 4847831C
                  7F00C58E FB847886 C544E836 524AB0E2

   (i=3)  v[16] = 7A3BE783 997546C1 D45246DF EDB5F821 7F98A742 10E864E2
                  D4AB70D0 C63CB1AB 6038DA9E 414594B0 F2C218B5 8DA0DCB7
                  D7CD7AF5 AB4909DF 85031A52 C4EDFC98

   (i=4)  v[16] = 2A8B8CB7 1ACA82B2 14045D7F CC7258ED 383CF67C E090E7F9
                  3025D276 57D04DE4 994BACF0 F0982759 F17EE300 D48FC2D5
                  DC854C10 523898A9 C03A0F89 47D6CD88

   (i=5)  v[16] = C4AA2DDB 111343A3 D54A700A 574A00A9 857D5A48 B1E11989
                  6F5C52DF DD2C53A3 678E5F8E 9718D4E9 622CB684 92976076
                  0E41A517 359DC2BE 87A87DDD 643F9CEC

   (i=6)  v[16] = 3453921C D7595EE1 592E776D 3ED6A974 4D997CB3 DE9212C3
                  35ADF5C9 9916FD65 96562E89 4EAD0792 EBFC2712 2385F5B2
                  F34600FB D7BC20FB EB452A7B ECE1AA40

   (i=7)  v[16] = BE851B2D A85F6358 81E6FC3B 0BB28000 FA55A33A 87BE1FAD
                  4119370F 1E2261AA A1318FD3 F4329816 071783C2 6E536A8D
                  9A81A601 E7EC80F1 ACC09948 F849A584

   (i=8)  v[16] = 07E5B85A 069CC164 F9DE3141 A56F4680 9E440AD2 9AB659EA
                  3C84B971 21DBD9CF 46699F8C 765257EC AF1D998C 75E4C3B6
                  523878DC 30715015 397FEE81 4F1FA799

   (i=9)  v[16] = 435148C4 A5AA2D11 4B354173 D543BC9E BDA2591C BF1D2569
                  4FCB3120 707ADA48 565B3FDE 32C9C916 EAF4A1AB B1018F28
                  8078D978 68ADE4B5 9778FDA3 2863B92E



Aumasson, et al.        Expires 29 September 2024              [Page 13]

Internet-Draft        The BLAKE3 Hashing Framework            March 2024


   (i=10) v[16] = D9C994AA CFEC3AA6 700D0AB2 2C38670E AF6A1F66 1D023EF3
                  1D9EC27D 945357A5 3E9FFEBD 969FE811 EF485E21 A632797A
                  DEEF082E AF3D80E1 4E86829B 4DEAFD3A

           h[8] = 8C5E8C50 E2147C32 A32BA7E1 2F45EB4E 208B4537 293AD69E
                  4C9B994D 82596786

   BLAKE3("abc") = 50 8C 5E 8C 32 7C 14 E2 E1 A7 2B A3 4E EB 45 2F
                   37 45 8B 20 9E D6 3A 29 4D 99 9B 4C 86 67 59 82

Authors' Addresses

   Jean-Philippe Aumasson (editor)
   Taurus SA
   Taurus SA
   Place Ruth Boesiger 6
   CH-1201 Geneva
   Switzerland
   Email: jeanphilippe.aumasson@gmail.com
   URI:   https://taurushq.com


   Samuel Neves


   Jack O'Connor
   SpaceX
   356 167th Ave NE
   Bellevue WA 98008
   United States of America
   Email: oconnor663@gmail.com
   URI:   https://jacko.io


   Zooko Wilcox-O'Hearn
   Zcash















Aumasson, et al.        Expires 29 September 2024              [Page 14]
